#name: Continuous Delivery to the Replicated platform

on:
  push:
    paths:
    - '**'
    - '!**.md'
    - '!doc/**'
    - '!**.png'

jobs:
  package-chart:
    runs-on: ubuntu-latest
    outputs:
      chart: ${{ steps.package-chart.outputs.package }}
      chart-version: ${{ steps.package-chart.outputs.chart-version }}
    steps:
    - uses: actions/checkout@v3
    - name: Get release channel
      id: get-channel
      shell: bash
      run: |
        if [[ ${GITHUB_REF_NAME} == "main" ]] ; then
          echo "channel=Unstable" >> $GITHUB_OUTPUT
        fi 
        echo "channel=${GITHUB_REF_NAME}"
    - name: Get short SHA sum
      id: get-short-rev
      shell: bash
      run: echo "short-rev=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
    - name: Get the expected chart version
      id: get-chart-version
      uses: mikefarah/yq@master
      with:
        cmd: yq '.version' Chart.yaml
    - name: Package Helm chart with a build-specific version
      id: package-chart
      run: |
        version="${CHART_VERSION}.build.${SHORT_SHA}"
        helm package . --version="${version}" -u 
        echo "package=gitea-${version}.tgz" >> $GITHUB_OUTPUT
        echo "chart-version=${version}" >> $GITHUB_OUTPUT
      env:
        CHART_VERSION: ${{ steps.get-chart-version.outputs.result }}
        SHORT_SHA: ${{ steps.get-short-rev.outputs.short-rev }}
    - name: Upload chart artifact
      id: uplaad-chart
      uses: actions/upload-artifact@v3
      with:
        name: chart
        path: ${{ steps.package-chart.outputs.package }}
          
  # Create a Replicated release without promoting to a channel. The Replicated
  # CLI isn't super scripting friendly when it comes to creating releases, so
  # this job uses a few different calls with curl instead.
  create-release:
    runs-on: ubuntu-latest
    needs: package-chart
    outputs:
      release-sequence: ${{ steps.create-release.outputs.release-sequence }}
    steps:
      - name: Download chart artifact
        id: get-chart
        uses: actions/download-artifact@v3
        with:
          name: chart
      - name: Install Replicated CLI
        id: install-cli
        run: |
          curl -o install.sh -sSL https://raw.githubusercontent.com/replicatedhq/replicated/master/install.sh
          bash ./install.sh
      - name: Create Release
        id: create-release
        run: |
          set -euxo pipefail
          app_id="$(replicated api get /v3/apps \
                      | jq --raw-output --arg slug ${REPLICATED_APP} '.apps[] | select ( .slug == $slug ) | .id')"
          jq --null-input --compact-output --arg chart ${CHART} --rawfile content <(base64 -w 0 ${CHART}) '[ {"name": $chart, "path": $chart, "content": $content}]' \
            | gzip --to-stdout \
            | base64 -w 0 > spec.gz
          sequence="$(curl --location "https://api.replicated.com/vendor/v3/app/${app_id}/release" \
                        --header 'Content-Type: application/json' \
                        --header 'Accept: application/json' \
                        --header "Authorization: ${REPLICATED_API_TOKEN}" \
                        --data @<(jq --null-input --compact-output --rawfile spec_gzip spec.gz '{ "spec_gzip", $spec_gzip }') \
                        --silent --show-error \
                      | jq --compact-output '.release.sequence')"
          echo "release-sequence=${sequence}" >> $GITHUB_OUTPUT
        env:
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          CHART: ${{ needs.package-chart.outputs.chart }}
       
  smoke-test:
    runs-on: ubuntu-latest
    needs: 
      - create-release
      - package-chart
    strategy:
      fail-fast: false
      matrix:
        cluster: [ {distribution: k3s, version: v1.25}, {distribution: k3s, version: v1.26}]
    outputs:
      sequence: ${{ steps.create-release.outputs.release-sequence }}
    steps:
      - name: Install Replicated CLI
        id: install-cli
        run: |
          curl -o install.sh -sSL https://raw.githubusercontent.com/replicatedhq/replicated/master/install.sh
          bash ./install.sh
      - name: Create test customer
        id: create-customer
        run: |
          set -euxo pipefail
          customer=$(replicated customer create --type test --name ${CUSTOMER_NAME} --email smoke@${GITHUB_REF_NAME}.test --output json)
          customer_id=$(echo "${customer}" | jq --raw-output .id)
          customer_password=$(echo "${customer}" | jq --raw-output .installationId)
          echo "customer-id=${customer_id}" >> $GITHUB_OUTPUT
          echo "customer-login=${CUSTOMER_EMAIL}" >> $GITHUB_OUTPUT
          echo "customer-password=${customer_password}" >> $GITHUB_OUTPUT
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          CUSTOMER_NAME: ${{ github.ref_name }}@${{ github.sha }}.${{github.job }}.${{ github.run_attempt }}
          CUSTOMER_EMAIL: ${{ github.job }}.${{github.run_attempt}}@${{ github.sha }}.test
      - name: Create test cluster
        id: create-cluster
        run: |
          set -euxo pipefail
          cluster_id=$(replicated cluster create --name ${CLUSTER_NAME} --distribution ${DISTRO} --version ${VERSION} --wait ${WAIT} --output json | jq --raw-output .id)
          echo "cluster-id=${cluster_id}" >> $GITHUB_OUTPUT
          echo "cluster-name=${CLUSTER_NAME}" >> $GITHUB_OUTPUT
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          CLUSTER_NAME: ${{ github.ref_name}}@${{ github.sha }}-${{github.job }}-${{ github.run_attempt }}
          DISTRO: ${{ matrix.cluster.distribution }}
          VERSION: ${{ matrix.cluster.version }}
          WAIT: 5m
      # Currenctly the smoke test workflow is not injecting replicated values into the chart,
      # so I'm manually preparing the value that's referenced in the proxy registry secret so
      # the Helm chart renders
      - name: Prepare registry secret
        id: prepare-secret
        run: |
          dockerconfig_json=$(jq --null-input --compact-output --arg authString ${AUTH_STRING} '{"auths":{"proxy.replicated.com":{"auth": $authString | @base64 },"registry.replicated.com":{"auth": $authString | @base64 }}}' | base64 -w 0)
          echo "dockerconfig-json=${dockerconfig_json}" >> $GITHUB_OUTPUT
        env:
          AUTH_STRING: ${{ steps.create-customer.ouptuts.customer-password }}:${{ steps.create-customer.outputs.customer-password }} 
      - name: Install to test cluster
        id: install-chart
        run: |
          set -euxo pipefail
          replicated cluster kubeconfig --id ${CLUSTER_ID}
          helm registry login ${REGISTRY} --username ${CUSTOMER_LOGIN} --password ${CUSTOMER_PASSWORD}
          helm install gitea ${CHART} --set global.replicated.dockerconfigjson=${DOCKERCONFIG_JSON} --version ${CHART_VERSION}
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          REGISTRY: registry.replicated.com
          CHART: oci://registry.replicated.com/${{ secrets.REPLICATED_APP }}/release__${{ needs.create-release.outputs.release-sequence }}/gitea
          CLUSTER_ID: ${{ steps.create-cluster.outputs.cluster-id }}
          CUSTOMER_LOGIN: ${{ steps.create-customer.outputs.customer-login }}
          CUSTOMER_PASSWORD: ${{ steps.create-customer.outputs.customer-password }}
          DOCKERCONFIG_JSON: ${{ steps.prepare-secret.outputs.dockerconfig-json }}
          CHART_VERSION: ${{ needs.package-chart.outputs.chart-version }}
      - name: Delete test cluster
        id: delete-cluster
        if: always()
        run: |
          set -euxo pipefail
          replicated cluster rm ${CLUSTER_ID}
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          CLUSTER_ID: ${{ steps.create-cluster.outputs.cluster-id }}
      - name: Delete test customer
        id: delete-customer
        if: always()
        run: |
          set -euxo pipefail
          replicated customer archive --customer ${CUSTOMER_ID}
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          CUSTOMER_ID: ${{ steps.create-customer.outputs.customer-id }}

  promote-release:
    runs-on: ubuntu-latest
    needs: 
      - create-release
      - smoke-test
    steps:
      - uses: actions/checkout@v3
      - name: Install Replicated CLI
        id: install-cli
        run: |
          curl -o install.sh -sSL https://raw.githubusercontent.com/replicatedhq/replicated/master/install.sh
          bash ./install.sh
      - name: Get the channel for the release
        id: get-channel
        run: |
          if [[ "${GITHUB_REF_NAME}" == "main" ]] ; then 
            echo "channel=Unstable" >> $GITHUB_OUTPUT
          fi
          echo "channel=${GITHUB_REF_NAME}" >> $GITHUB_OUTPUT
      - name: Assure channel exists
        id: assure-channel
        run: |
          set -euxo pipefail
          app_id="$(replicated api get /v3/apps \
                      | jq --raw-output --arg slug ${REPLICATED_APP} '.apps[] | select ( .slug == $slug ) | .id')"
          channel_id=$(replicated api get /v3/app/${app_id} | jq --raw-output --arg channel ${CHANNEL} '.app.channels[] | select ( .name == $channel ) | .id')
          if [[ -z "${channel_id}" ]]; then
            replicated api post /v3/app/${app_id}/channel -b "$(jq --compact-output --arg channel ${CHANNEL} { \"name\": $channel }')"
          fi
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
          CHANNEL: ${{ steps.get-channel.outputs.channel }}
      - name: Promote the release
        id: promote-release
        uses: docker://replicated/vendor-cli:latest
        with:
          args: release promote ${{ needs.create-release.outputs.release-sequence }} ${{ steps.get-channel.outputs.channel }}
        env:
          REPLICATED_API_TOKEN: ${{ secrets.REPLICATED_API_TOKEN }}
          REPLICATED_APP: ${{ secrets.REPLICATED_APP }}
